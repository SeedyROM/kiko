#!/bin/bash

# Print usage information
usage() {
    cat << EOF
Usage: $0 [OPTIONS]

Start Kiko development or release servers.

Options:
  -r, --release                      Start in release mode (optimized builds)
  -be, --backend-address=ADDRESS     Set backend server address 
                                     (default: http://localhost:3030)
  -fe, --frontend-address=ADDRESS    Set frontend server address
                                     (default: http://localhost:8080)
  -h, --help                         Show this help message

Examples:
  $0                                    Start in development mode
  $0 --release                          Start in release mode
  $0 -be=http://0.0.0.0:3030            Start with custom backend address
  $0 --release -fe=http://0.0.0.0:8080  Release mode with custom frontend

EOF
}

# Parse command line arguments
RELEASE_MODE=false
BACKEND_ADDRESS="http://localhost:3030"
FRONTEND_ADDRESS="http://localhost:8080"

while [[ $# -gt 0 ]]; do
    case $1 in
        -r|--release)
            RELEASE_MODE=true
            shift
            ;;
        -be=*|--backend-address=*)
            BACKEND_ADDRESS="${1#*=}"
            shift
            ;;
        -be|--backend-address)
            BACKEND_ADDRESS="$2"
            shift 2
            ;;
        -fe=*|--frontend-address=*)
            FRONTEND_ADDRESS="${1#*=}"
            shift
            ;;
        -fe|--frontend-address)
            FRONTEND_ADDRESS="$2"
            shift 2
            ;;
        -h|--help)
            usage
            exit 0
            ;;
        *)
            echo "Error: Unknown argument '$1'"
            echo
            usage
            exit 1
            ;;
    esac
done

# Store original directory
ORIGINAL_DIR=$(pwd)

# Flag to prevent duplicate cleanup
CLEANUP_DONE=false

# Cleanup function to kill background processes and return to original directory
cleanup() {
    # Prevent duplicate execution
    if [ "$CLEANUP_DONE" = true ]; then
        return 0
    fi
    CLEANUP_DONE=true
    
    echo -e "\n${LOGO_COLOR}üõë Shutting down servers...${NC}"
    
    # Kill specific PIDs if we have them
    if [ -n "$BACKEND_PID" ]; then
        echo -e "${LOGO_COLOR}  Stopping backend (PID: $BACKEND_PID)...${NC}"
        kill -TERM "$BACKEND_PID" 2>/dev/null
        sleep 0.01
        kill -KILL "$BACKEND_PID" 2>/dev/null
    fi
    
    if [ -n "$FRONTEND_PID" ]; then
        echo -e "${LOGO_COLOR}  Stopping frontend (PID: $FRONTEND_PID)...${NC}"
        kill -TERM "$FRONTEND_PID" 2>/dev/null
        sleep 0.01
        kill -KILL "$FRONTEND_PID" 2>/dev/null
    fi
    
    # Kill any remaining cargo/trunk processes
    pkill -f "cargo.*watch.*run" 2>/dev/null || true
    pkill -f "trunk.*serve" 2>/dev/null || true
    pkill -f "kiko-backend" 2>/dev/null || true
    
    # Kill all background jobs as fallback
    if jobs -p > /dev/null 2>&1; then
        local pids=$(jobs -p)
        if [ -n "$pids" ]; then
            kill -TERM $pids 2>/dev/null
            sleep 0.01
            kill -KILL $pids 2>/dev/null
        fi
    fi
    
    # Clean up temp files
    rm -f /tmp/kiko_cargo_watch.log 2>/dev/null
    
    # Return to original directory
    cd "$ORIGINAL_DIR"
    
    echo -e "${LOGO_COLOR}‚úÖ Cleanup complete${NC}"
}

# Set up signal handlers
trap cleanup EXIT
trap cleanup INT
trap cleanup TERM

# ANSI color codes
CLIENT_COLOR='\033[38;5;117m' # Light blue
SERVER_COLOR='\033[38;5;179m' # Light yellow
LOGO_COLOR='\033[38;5;189m' # Light magenta
NC='\033[0m' # Stop color

# Function to monitor cargo watch for errors and provide helpful feedback
smart_cargo_watch() {
    local log_file="/tmp/kiko_cargo_watch.log"
    local error_count=0
    local last_error_time=0
    local build_success_count=0
    
    # Start cargo watch and capture output without subshell
    exec 3< <(cargo watch -w src -x run 2>&1 | tee "$log_file")
    
    while IFS= read -r line <&3; do
        echo -e "${SERVER_COLOR}[server]${NC} $line"
        
        # Check for compilation errors
        if echo "$line" | grep -q -E "error\[E[0-9]+\]|error:|compilation failed|could not compile" && \
           ! echo "$line" | grep -q -E "warning:|note:|help:"; then
            
            current_time=$(date +%s)
            
            # Reset error count if it's been a while since last error
            if [ $((current_time - last_error_time)) -gt 60 ]; then
                error_count=0
            fi
            
            error_count=$((error_count + 1))
            last_error_time=$current_time
            
            if [ $error_count -eq 1 ]; then
                echo -e "${SERVER_COLOR}[server]${NC} üö® Compilation error detected - backend won't start until fixed"
            elif [ $error_count -eq 3 ]; then
                echo -e "${SERVER_COLOR}[server]${NC} üí° Tip: Fix the compilation errors above and save to trigger rebuild"
            elif [ $error_count -ge 5 ]; then
                echo -e "${SERVER_COLOR}[server]${NC} üîÑ Still waiting for error fixes... (Press Ctrl+C to stop)"
                error_count=0  # Reset to avoid spam
            fi
        fi
        
        # Check for successful compilation
        if echo "$line" | grep -q "Finished.*dev.*target"; then
            if [ $error_count -gt 0 ]; then
                echo -e "${SERVER_COLOR}[server]${NC} ‚úÖ Compilation successful! Backend should be starting..."
            fi
            error_count=0
            build_success_count=$((build_success_count + 1))
        fi
        
        # Check if the server actually started
        if echo "$line" | grep -q -E "Server running|Listening on|Started|Rocket has launched"; then
            echo -e "${SERVER_COLOR}[server]${NC} üöÄ Backend server is now running!"
        fi
    done
    
    exec 3<&-
}

# Function to check if backend is ready with better error reporting
check_backend_health() {
    local max_attempts=20  # Reduced attempts since we have better error handling
    local attempt=0
    local backend_url="${BACKEND_ADDRESS}"
    local consecutive_failures=0
    local warned_about_errors=false
    
    echo -e "${LOGO_COLOR}‚è≥ Waiting for backend to be ready...${NC}"
    
    while [ $attempt -lt $max_attempts ]; do
        # Check if backend process is still running
        if [ -n "$BACKEND_PID" ] && ! kill -0 "$BACKEND_PID" 2>/dev/null; then
            echo -e "\n${LOGO_COLOR}‚ùå Backend process died unexpectedly${NC}"
            return 1
        fi
        
        # Try to connect to the backend
        if curl -s -f "$backend_url/health" >/dev/null 2>&1 || \
           curl -s -f "$backend_url" >/dev/null 2>&1 || \
           nc -z localhost 3030 >/dev/null 2>&1; then
            echo -e "${LOGO_COLOR}‚úÖ Backend is ready!${NC}"
            return 0
        fi
        
        consecutive_failures=$((consecutive_failures + 1))
        
        # After several failures, provide helpful guidance
        if [ $consecutive_failures -eq 8 ] && [ "$RELEASE_MODE" = false ] && [ "$warned_about_errors" = false ]; then
            echo -e "\n${LOGO_COLOR}‚ö†Ô∏è  Backend not responding yet...${NC}"
            echo -e "${LOGO_COLOR}üí° This might be due to:${NC}"
            echo -e "${LOGO_COLOR}   ‚Ä¢ Compilation errors (check server output above)${NC}"
            echo -e "${LOGO_COLOR}   ‚Ä¢ Slow build process (first build can take longer)${NC}"
            echo -e "${LOGO_COLOR}   ‚Ä¢ Missing dependencies${NC}"
            echo -e "${LOGO_COLOR}üîÑ Continuing to wait, or press Ctrl+C to stop...${NC}"
            warned_about_errors=true
        fi
        
        attempt=$((attempt + 1))
        sleep 3
    done
    
    echo -e "\n${LOGO_COLOR}‚ùå Backend failed to start within 60 seconds${NC}"
    echo -e "${LOGO_COLOR}üí° Check the server output above for error messages${NC}"
    return 1
}

# Function to check if a command exists and is executable
command_exists() {
    command -v "$1" >/dev/null 2>&1
}

# Function to check directory exists
check_directory() {
    local dir="$1"
    local name="$2"
    
    if [ ! -d "$dir" ]; then
        echo "‚ùå $name directory not found: $dir"
        echo "   Make sure you're running this script from the correct location."
        return 1
    fi
    return 0
}

# Check if required tools are installed
echo "üîç Checking dependencies..."

if ! command_exists rustc; then
    echo "‚ùå Rust is not installed. Please install Rust to run this script."
    echo "   Visit: https://rustup.rs/"
    exit 1
fi

if ! command_exists trunk; then
    echo "‚ùå Trunk is not installed. Please install Trunk to run this script."
    echo "   Run: cargo install trunk"
    exit 1
fi

if [ "$RELEASE_MODE" = false ] && ! command_exists cargo-watch; then
    echo "‚ùå Cargo Watch is not installed. Please install Cargo Watch to run this script."
    echo "   Run: cargo install cargo-watch"
    exit 1
fi

if ! command_exists npm && ! command_exists npx; then
    echo "‚ùå npm or npx is not installed. Please install Node.js to run this script."
    echo "   Visit: https://nodejs.org/"
    exit 1
fi

# Check if curl or nc is available for health checks
if ! command_exists curl && ! command_exists nc; then
    echo "‚ö†Ô∏è  Warning: Neither curl nor nc found. Backend health check will be basic."
    HEALTH_CHECK_AVAILABLE=false
else
    HEALTH_CHECK_AVAILABLE=true
fi

# Check if required directories exist
if ! check_directory "crates/kiko-backend" "Backend" || \
   ! check_directory "crates/kiko-frontend" "Frontend"; then
    exit 1
fi

echo "‚úÖ All dependencies found"

# Function to kill processes on specific ports
kill_port_processes() {
    local port=$1
    local port_name=$2
    
    # Find processes using the port
    local pids=$(lsof -ti:$port 2>/dev/null || true)
    
    if [ -n "$pids" ]; then
        echo -e "${LOGO_COLOR}üîÑ Killing existing $port_name processes on port $port...${NC}"
        for pid in $pids; do
            if kill -0 "$pid" 2>/dev/null; then
                echo -e "${LOGO_COLOR}  Stopping process $pid...${NC}"
                kill -TERM "$pid" 2>/dev/null || true
                sleep 0.5
                # Force kill if still running
                if kill -0 "$pid" 2>/dev/null; then
                    kill -KILL "$pid" 2>/dev/null || true
                fi
            fi
        done
        echo -e "${LOGO_COLOR}‚úÖ Port $port is now free${NC}"
    fi
}

# Kill any existing processes on our target ports
echo "üßπ Cleaning up existing processes..."
kill_port_processes 3030 "backend"
kill_port_processes 8080 "frontend"

# Print logo
echo -e "${LOGO_COLOR}"
echo "  ,--. ,--.,--.,--.          "
echo "  |  .'   /\`--'|  |,-. ,---. "
echo "  |  .   ' ,--.|     /| .-. |"
echo "  |  |\   \|  ||  \  \' '-' '"
echo "  \`--' '--'\`--'\`--'\`--'\`---' "
echo -e "${NC}"

echo "   üì° Backend:  ${BACKEND_ADDRESS}"
echo "   üé® Frontend: ${FRONTEND_ADDRESS}"
echo
echo -e "${LOGO_COLOR}üí° Development Tips:${NC}"
echo -e "${LOGO_COLOR}   ‚Ä¢ Fix compilation errors to restart the backend${NC}"
echo -e "${LOGO_COLOR}   ‚Ä¢ Changes auto-reload when you save files${NC}"
echo -e "${LOGO_COLOR}   ‚Ä¢ Press Ctrl+C to stop both servers${NC}"
echo

# Initialize PID variables
BACKEND_PID=""
FRONTEND_PID=""

if [ "$RELEASE_MODE" = true ]; then
    echo "üöÄ Starting Kiko release servers..."
    
    # Start backend in release mode
    echo "üì° Starting backend server (release)..."
    cd crates/kiko-backend || {
        echo "‚ùå Failed to change to backend directory"
        exit 1
    }
    
    # Check if Cargo.toml exists
    if [ ! -f "Cargo.toml" ]; then
        echo "‚ùå Backend Cargo.toml not found. Are you in the right directory?"
        exit 1
    fi
    
    # Start backend with better error handling
    (cargo run --release 2>&1 | awk -v prefix="${SERVER_COLOR}[server]${NC}" '{print prefix " " $0; fflush()}') &
    BACKEND_PID=$!
    
    # Check if cargo command started successfully
    sleep 2
    if ! kill -0 "$BACKEND_PID" 2>/dev/null; then
        echo "‚ùå Failed to start backend process"
        exit 1
    fi
else
    echo "üöÄ Starting Kiko development servers..."
    
    # Start backend with watch mode
    echo "üì° Starting backend server (dev watch)..."
    cd crates/kiko-backend || {
        echo "‚ùå Failed to change to backend directory"
        exit 1
    }
    
    # Check if Cargo.toml exists
    if [ ! -f "Cargo.toml" ]; then
        echo "‚ùå Backend Cargo.toml not found. Are you in the right directory?"
        exit 1
    fi
    
    # Use our smart cargo watch function
    smart_cargo_watch &
    BACKEND_PID=$!
    
    # Check if cargo-watch command started successfully
    sleep 2
    if ! kill -0 "$BACKEND_PID" 2>/dev/null; then
        echo "‚ùå Failed to start backend watch process"
        exit 1
    fi
fi

# Wait for backend to be ready (with better error handling)
if [ "$HEALTH_CHECK_AVAILABLE" = true ]; then
    if ! check_backend_health; then
        echo "‚ùå Failed to start backend. Common solutions:"
        echo "   ‚Ä¢ Check for compilation errors in the output above"
        echo "   ‚Ä¢ Ensure all dependencies are installed (cargo check)"
        echo "   ‚Ä¢ Make sure port 3030 is not already in use"
        echo "   ‚Ä¢ Try running 'cargo run' manually in the backend directory"
        exit 1
    fi
else
    # Fallback to simple sleep if health check tools aren't available
    echo -e "${LOGO_COLOR}‚è≥ Waiting 8 seconds for backend to start...${NC}"
    sleep 8
    
    # Basic check if backend process is still running
    if [ -n "$BACKEND_PID" ] && ! kill -0 "$BACKEND_PID" 2>/dev/null; then
        echo "‚ùå Backend process died during startup"
        echo "üí° Run the script again or check for compilation errors"
        exit 1
    fi
fi

# Change to frontend directory
cd "$ORIGINAL_DIR/crates/kiko-frontend" || {
    echo "‚ùå Failed to change to frontend directory"
    exit 1
}

# Check if frontend files exist
if [ ! -f "Trunk.toml" ] && [ ! -f "index.html" ]; then
    echo "‚ùå Frontend files not found. Are you in the right directory?"
    echo "   Looking for Trunk.toml or index.html in: $(pwd)"
    exit 1
fi

# Start frontend
if [ "$RELEASE_MODE" = true ]; then
    echo "üé® Starting frontend server (release)..."
    (trunk serve --release 2>&1 | awk -v prefix="${CLIENT_COLOR}[client]${NC}" '{print prefix " " $0; fflush()}') &
    FRONTEND_PID=$!
else
    echo "üé® Starting frontend server (dev)..."
    (trunk serve 2>&1 | awk -v prefix="${CLIENT_COLOR}[client]${NC}" '{print prefix " " $0; fflush()}') &
    FRONTEND_PID=$!
fi

# Check if frontend started successfully
sleep 3
if [ -n "$FRONTEND_PID" ] && ! kill -0 "$FRONTEND_PID" 2>/dev/null; then
    echo "‚ùå Failed to start frontend process"
    echo "üí° Check if trunk is properly installed: cargo install trunk"
    exit 1
fi

echo -e "\n${LOGO_COLOR}üéâ Both servers are running!${NC}"
echo -e "${LOGO_COLOR}üåê Backend:  ${BACKEND_ADDRESS}${NC}"
echo -e "${LOGO_COLOR}üé® Frontend: ${FRONTEND_ADDRESS}${NC}"
echo -e "${LOGO_COLOR}üìù Watch mode: Files will auto-reload on save${NC}"
echo -e "${LOGO_COLOR}üõë Press Ctrl+C to stop both servers${NC}\n"

# Wait for user interrupt
wait